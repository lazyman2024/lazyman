#1.find the maximum element in an array
def find_max(arr):
    # Step 1: Initialize the maximum value as the first element
    max_val = arr[0]
    
    # Step 2: Loop through the array starting from the second element
    for num in arr[1:]:
        if num > max_val:
            max_val = num  # Update max_val if current number is greater
    
    # Step 3: Return the maximum value
    return max_val

arr=[10,20,30,40,50]
print(find_max(arr))

#2.implement stack using arrays and perform basic stack operations.
class Stack:
    def __init__(self):
        self.stack = []  
    # Push operation: Add an element to the top
    def push(self, element):
        self.stack.append(element)
        print(f"Pushed {element}")

    # Pop operation: Remove and return the top element
    def pop(self):
        if not self.is_empty():
            return self.stack.pop()  
        else:
            return "Stack is empty" 

    # Peek operation: Return the top element without removing it
    def peek(self):
        if not self.is_empty():
            return self.stack[-1]  
        else:
            return "Stack is empty"

    # isEmpty operation: Check if the stack is empty
    def is_empty(self):
        return len(self.stack) == 0

    # Display the stack (optional, for visual representation)
    def display(self):
        print("Stack:", self.stack)
s=Stack()
s.push(10)           #
s.push(20)
s.push(30)
print(s.pop())
print(s.peek())
print(s.pop())
print(s.display())


#3.design a queue using two stack and demonstrate enqueue and dequeue operations
class QueueUsingStacks:
    def __init__(self):
        self.stack1 = []  # Stack1 for enqueue
        self.stack2 = []  # Stack2 for dequeue

    # Enqueue operation: Push element to stack1
    def enqueue(self, element):
        self.stack1.append(element)
        print(f"Enqueued {element}")

    # Dequeue operation: Move elements from stack1 to stack2 if stack2 is empty
    def dequeue(self):
        if not self.stack2:  # If stack2 is empty  
            while self.stack1:  # Move elements from stack1 to stack2
                self.stack2.append(self.stack1.pop())
        
        if not self.stack2:  # If stack2 is still empty after transfer, queue is empty
            return "Queue is empty"
        return self.stack2.pop()  # Pop from stack2

    # Display queue (optional)
    def display(self):
        # Stack2 holds the front elements, stack1 holds the back elements (in reverse)
        print("Queue:", self.stack2 + self.stack1[::-1])
q=QueueUsingStacks()
q.enqueue(10)
q.enqueue(20)
q.enqueue(30)
print(q.display())
print(q.dequeue())
print(q.dequeue())
print(q.dequeue())
print(q.dequeue())

4....implement a function to detect a cycle in a linked list
class ListNode:
    def __init__(self, value=0, next=None):
        self.value = value
        self.next = next

def has_cycle(head):
    # Step 1: Initialize slow and fast pointers
    slow = head
    fast = head
    
    # Step 2: Traverse the linked list
    while fast and fast.next:
        slow = slow.next        # Move slow by 1 step
        fast = fast.next.next   # Move fast by 2 steps
        
        # Step 3: Check if slow and fast meet (cycle detected)
        if slow == fast:
            return True
    
    # Step 4: If fast reaches the end, no cycle
    return False

head1= ListNode(1)
secondnode=ListNode(2)
head1.next=secondnode
head1.next.next=ListNode(3)
head1.next.next.next=ListNode(4)
head1.next.next.next.next=secondnode
print("does linked list have a cycle?",has_cycle(head1))

5.#5.implement the merge sort

def binary_search(arr, target):
    low = 0
    high = len(arr) - 1
    
    while low <= high:
        mid = (low + high) // 2
        
        if arr[mid] == target:
            return mid
        elif arr[mid] > target:
            high = mid - 1
        else:
            low = mid + 1
    
    return -1
arr = [1, 2, 4, 5, 7, 8, 10]
target = 5
result = binary_search(arr, target)
print(f"Element {target} found at index {result}")


6..#6.implement the binary search 
def binary_search(arr, target):
    # Step 1: Initialize pointers
    low = 0
    high = len(arr) - 1
    
    # Step 2: Loop until the pointers overlap
    while low <= high:
        # Step 3: Calculate the middle index
        mid = (low + high) // 2
        
        # Step 4: Check if the middle element is the target
        if arr[mid] == target:
            return mid  # Element found, return its index
        
        # Step 5: If the target is smaller than mid, move to the left half
        elif arr[mid] > target:
            high = mid - 1
        
        # Step 6: If the target is larger than mid, move to the right half
        else:
            low = mid + 1
    
    # Step 7: If the loop exits, the target was not found
    return -1

# Example usage:
arr = [1, 2, 4, 5, 7, 8, 10]
target = 8
result = binary_search(arr, target)

# Display the result
if result != -1:
    print(f"Element {target} found at index {result}")
else:
    print(f"Element {target} not found in the array")


7....7.#implement the fibonaci series using dynamic programming.
def fibonacci(n):
    # Step 1: Create a dp array to store Fibonacci numbers
    dp = [0] * (n + 1)
    
    # Step 2: Base cases
    dp[0] = 0
    if n > 0:
        dp[1] = 1
    
    # Step 3: Fill the dp array using the relation F(n) = F(n-1) + F(n-2)
    for i in range(2, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
    
    # Return the nth Fibonacci number
    return dp[n]

# Example usage
n = 10
print(f"Fibonacci number F({n}) is:", fibonacci(n))


9.#implement the binary search tree

class Node:
    def __init__(self, value):
        self.value = value  # Node stores a value
        self.left = None    # Left child (initially None)
        self.right = None   # Right child (initially None)

class BinarySearchTree:
    def __init__(self):
        self.root = None  # Initially, the tree is empty

    # Function to insert a value into the BST
    def insert(self, value):
        if self.root is None:  # If the tree is empty
            self.root = Node(value)  # The first node becomes the root
        else:
            self._insert_recursive(self.root, value)  # Insert recursively

    # Helper function to insert a value recursively
    def _insert_recursive(self, node, value):
        if value < node.value:  # If the value is smaller, go left
            if node.left is None:
                node.left = Node(value)  # Insert as left child
            else:
                self._insert_recursive(node.left, value)  # Recur for left subtree
        else:  # If the value is larger, go right
            if node.right is None:
                node.right = Node(value)  # Insert as right child
            else:
                self._insert_recursive(node.right, value)  # Recur for right subtree

    # Function to find the height of the BST
    def find_height(self, node):
        if node is None:
            return -1  # Base case: empty tree has height -1
        left_height = self.find_height(node.left)   # Find height of left subtree
        right_height = self.find_height(node.right) # Find height of right subtree
        return 1 + max(left_height, right_height)   # Take the maximum height + 1 for the current node

    # In-order traversal (left -> current node -> right)
    def inorder_traversal(self, node):
        if node is not None:
            self.inorder_traversal(node.left)  # Visit left subtree
            print(node.value, end=" ")         # Visit current node
            self.inorder_traversal(node.right) # Visit right subtree

# Create a new binary search tree
bst = BinarySearchTree()

# Insert elements into the tree
elements = [10, 5, 20, 3, 7, 15, 25]
for element in elements:
    bst.insert(element)

# Find and print the height of the tree
print("Height of the tree:", bst.find_height(bst.root))

# Perform in-order traversal (prints the elements in sorted order)
print("In-order traversal of the tree:")
bst.inorder_traversal(bst.root)
print()  # For clean output formatting
